use register::{
    mmio::ReadWrite,
    register_structs, register_bitfields,
};

register_bitfields! {
    u32,

    /// CPU Interface Control Register
    pub CTLR [
        /// Enable for the signaling of Group 1 interrupts by the CPU interface to the connected processor
        ///
        /// When this bit is cleared to 0, the CPU interface ignores any pending interrupt forwarded to
        /// it. When this bit is set to 1, the CPU interface starts to process pending interrupts that are
        /// forwarded to it. There is a small but finite time required for a change to take effect
        Enable OFFSET(0) NUMBITS(1) []
    ],

    /// Interrupt Priority Mask Register
    pub PMR [
        /// The priority mask level for the CPU interface. If the priority of an interrupt is higher than the
        /// value indicated by this field, the interface signals the interrupt to the processor
        Priority OFFSET(0) NUMBITS(8) []
    ],

    /// Interrupt Acknowledge Register
    ///
    /// The processor reads this register to obtain the interrupt ID of the signaled interrupt. This
    /// read acts as an acknowledge for the interrupt.
    pub IAR [
        /// For SGIs in a multiprocessor implementation, this field identifies the processor that
        /// requested the interrupt. It returns the number of the CPU interface that made the
        /// request, for example a value of 3 means the request was generated by a write to the
        /// GICD_SGIR on CPU interface 3.
        /// For all other interrupts this field is RAZ.
        CPUID OFFSET(10) NUMBITS(3) [],
        /// The interrupt ID.
        InterruptID OFFSET(0) NUMBITS(10) []
    ],

    /// End of Interrupt Register
    ///
    /// A processor writes to this register to inform the CPU interface either:
    /// - that it has completed the processing of the specified interrupt
    /// - in a GICv2 implementation, when the appropriate GICC_CTLR.EOImode bit is set
    /// to 1, to indicate that the interface should perform priority drop for the specified
    /// interrupt.
    pub EOIR [
        /// On a multiprocessor implementation, if the write refers to an SGI, this field contains
        /// the CPUID value from the corresponding GICC_IAR access.
        /// In all other cases this field SBZ.
        CPUID OFFSET(10) NUMBITS(3) [],
        /// The Interrupt ID value from the corresponding GICC_IAR access.
        EOIINTID OFFSET(0) NUMBITS(10) []
    ]
}

register_structs! {
    pub RegisterBlock {
        (0x000 => pub ctlr: ReadWrite<u32, CTLR::Register>),
        (0x004 => pub pmr: ReadWrite<u32, PMR::Register>),
        (0x008 => _reserved1),
        (0x00C => pub iar: ReadWrite<u32, IAR::Register>),
        (0x010 => pub eoir: ReadWrite<u32, EOIR::Register>),
        (0x014  => @END),
    }
}
